Порядок поиска свойств:
1. В самом объекте (this)
2. В [[Prototype]] (прототип, __proto__)
3. В [[Environment]] (лексическое окружение)
4. Если свойство не найдено возвращается undefined

Прототип может быть только объектом или null

По умолчанию прототипом объекта является Object.prototype, Object.prototype.__proto__ === null

Для того, чтобы задать свой прототип объекту необходимо изменить его свойство __proto__;

let user = {
name = "John";}
user.__proto__ = {isAdmin: false;}

console.log(user.isAdmin); // false

Функция конструктор:

Когда функция вызывается как new User(...), происходит следующее:

Создаётся новый пустой объект, и он присваивается this.
Выполняется код функции. Обычно он модифицирует this, добавляет туда новые свойства.
Возвращается значение this.
Другими словами, вызов new User(...) делает примерно вот что:

function User(name) {
  // this = {};  (неявно)

  // добавляет свойства к this
  this.name = name;
  this.isAdmin = false;

  // return this;  (неявно)
}

Если объект создаётся с помощью конструктора, то прототип нужно указывать в свойстве prototype. По умолчанию свойство prototype есть у любой функции и содержит объект с одним свойство constructor. constructor ссылается на саму функцию. С помощью конструктор можно создать аналогичный объект, если не известно какая функция-конструктор использовалась для его создания: new rabbit.constructor("Black Rabbit");

Чтобы не потерять свойство constructor необходимо добавлять свойства к prototype, а не перезаписывать свойство prototype.

function Rabbit() {}
Rabbit.prototype = {
  jumps: true
};

let rabbit = new Rabbit();
alert(rabbit.constructor === Rabbit); // false

function Rabbit() {}

// Не перезаписываем Rabbit.prototype полностью,
// а добавляем к нему свойство
Rabbit.prototype.jumps = true
// Прототип по умолчанию сохраняется, и мы всё ещё имеем доступ к Rabbit.prototype.constructor

undefined и null не имеют прототипов

Примитивы создают временные объекты-обёртки когда требуется доступ к их свойствам и методам.