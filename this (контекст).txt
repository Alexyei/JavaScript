При вызове метода объекта, в лексическом окружении появляется свойство this которое, ссылается на этот объект.

Лексическое окружение и this это разные вещи!

В других случаях в строгом режиме this === undefined;

Но если метод сразу не вызывается, this не получит объект и будет undefined.

// разделим получение метода объекта и его вызов в разных строках
let hi = user.hi;
hi(); // Ошибка, потому что значением this является undefined

Для работы вызовов типа user.hi(), JavaScript использует трюк – точка '.' возвращает не саму функцию, а специальное значение «ссылочного типа», называемого Reference Type.

Этот ссылочный тип (Reference Type) является внутренним типом. Мы не можем явно использовать его, но он используется внутри языка.

Методы явного передачи контента(this) в функцию:
func.call(context, ...args); // передаёт массив как список с // оператором расширения (аргументы через запятую)
func.apply(context, args);   // тот же эффект, аргументы в   // массиве
f = f.bind(context, boundArgs); // возвращает объект, bind жёстко фиксирует контекст, дальше изменить его с помощью bind, apply, call или вызовом функции в другом объекте нельзя.

function f() {
    console.log(this.name);
}

f = f.bind( {name: "Вася"});
f.apply({name: "Петя"});

f();

output:
Вася
Вася